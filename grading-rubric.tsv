Code Quality	1 = Poor (buggy, inconsistent)	2 = Fair (some bugs, inconsistent style)	3 = Average (mostly correct, some style issues)	4 = Good (clean, mostly idiomatic)	5 = Excellent (robust, idiomatic, clean)
Organization	1 = Disorganized	2 = Some structure	3 = Moderately organized	4 = Well-structured	5 = Modular and layered
Readability	1 = Hard to read	2 = Somewhat readable	3 = Average readability	4 = Clear	5 = Very clear and well-commented
Accuracy of Output	1 = Mostly incorrect	2 = Some correct parts	3 = Mostly correct	4 = Correct with minor issues	5 = Fully correct
Deployment Readiness	1 = Not deployable	2 = Needs major work	3 = Needs minor work	4 = Mostly ready	5 = Fully production-ready
Security Awareness	1 = No security features	2 = Minimal security	3 = Some security	4 = Good security	5 = Secure by default
Documentation Quality	1 = None or poor	2 = Minimal	3 = Adequate	4 = Good	5 = Excellent
Coverage of Requirements	1 = <40% features implemented	2 = 40–60%	3 = 60–80%	4 = 80–99%	5 = 100%
					
					
Code Quality Units					
Aspect	Idiomatic Practice				
Naming Conventions	Use short, descriptive names (err, buf, req). Exported names are capitalized.				
Error Handling	Use 'if err != nil' consistently. Avoid deep nesting. Return early on error.				
Code Structure	Keep functions short and focused. Prefer composition over inheritance.				
Package Usage	Use standard library where possible (net/http, context, log).				
Formatting	Use gofmt or goimports to enforce consistent formatting.				
Concurrency	Use goroutines and channels appropriately. Avoid shared memory when possible.				
Interfaces	Define small interfaces. Use implicit implementation.				
Comments	Use comments for exported functions/types. Avoid redundant comments.				
Testing	Use *_test.go files with testing package. Keep tests simple and focused.				
Avoid Overengineering	Prefer simple solutions. Avoid unnecessary abstractions or patterns.				